\documentclass[
	11pt, 
	DIV10,
	ngerman,
	a4paper, 
	oneside, 
	headings=normal, 
	captions=tableheading,
	final, 
	numbers=noenddot
]{scrartcl}


\usepackage[ruled]{algorithm2e}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

\title{Fully Asynchronous SPH Simulation}
\subtitle{\vspace{0.5cm}Lab: Fluid Simulation}
\author{Yinglun, Qihui, Iohannes}


\begin{document}
\maketitle


\section{Motivation}

In this work, we follow the basic principles of smoothed particle hydrodynamics(SPH) to implement two of the most classic approaches in fluid simulation. We carry out extensive studies on the behavior of fluid particles under varying experimental conditions, as well as provide a handful of insights on how the stability or efficiency of the simulation could be improved by applying a few twists during various stages of the algorithms. The rest of this report will be divided into four sections. In section \ref{sec2}, we underscore the engineering aspect of a non-iterative, weakly-compressible SPH solver; in section \ref{sec3}, we discuss how an iterative procedure can be implemented to model position-based fluid; in section \ref{sec4}, we demonstrate several scenes featuring a variety of fluid behaviors to show the correctness and stability of our implementation; in the last section \ref{sec5}, we discuss how the hyper parameters affect the behavior of the fluid and how we may improve the simulation in terms of speed and robustness.


\section{Weakly Compressible SPH}
\label{sec2}

In weakly compressible SPH, physical properties of fluid particles are updated through an array of explicit state equations. Fluid particles move around as a result of inter-particle interactions and external forces that act upon them. To find out where fluid particles should go in the next time step, typically pressure forces and viscosity forces are considered as the dominant components of the interaction forces. Pressure forces counteract any deviation from the rest density in the fluid volume. Viscosity forces counteracts the divergence of the velocity field in the local space. The outline of a single WC-SPH update is shown in Alg. \ref{alg1}.

At the beginning of such an update step, a neighborhood search is carried out to determine the spatial neighbors of each fluid particle. Fluid and solid particle neighbors are stored separately to facilitate instant evaluation of function values at discrete locations in the fluid domain, which in the context of WC-SPH takes the form of an interpolation. Such an interpolation requires the existence of an kernel function that features a variety of characters. Then, the fluid particle densities are estimated as they will be needed for the computation of interaction forces. As a logical next step, the incurred forces are evaluated for each particle and the accelerations are accumulated for time integration.

Apart from updating the physical state of the system, the particle sampling strategies for initializing the fluid and the boundary play an important role as well, since they indirectly determine the particle diameters and thus the smoothing length of the kernel function. Another key factor that needs to be handled with discretion is the time step size of each physical update. Too large a time step results in destabilized simulation and incorrect particle interactions, while too small a time step leads to considerable waste of computational power. In the following, we unfold in detail some key aspects for implementing such a WC-SPH solver.

\large
\begin{algorithm}
	\DontPrintSemicolon
	\SetAlgoLined
	\SetAlgorithmName{Algorithm}{Algorithm}{List of Algorithms}
	\SetAlCapNameSty{textbf}
	\caption{\label{alg1} A Single WC-SPH Update}
	\SetKwFunction{FMain}{update}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FMain{$ \Delta t $}}{
		\For{each particle i}{
			find neighbors j\;
		}
		\For{each particle i}{
			compute density $ \rho_{i} $\;
		}
		\For{each particle i}{
			compute pressure force $ \boldsymbol{F}_{i}^{p} $\;
			compute viscosity force $ \boldsymbol{F}_{i}^{v} $\;
			compute cohesion force $ \boldsymbol{F}_{i}^{c} $\;
			compute adhesion force $ \boldsymbol{F}_{i}^{a} $\;
			compute external force $ \boldsymbol{F}_{i}^{e} $\;
			compute acceleration $ \boldsymbol{a}_{i} $\;
		}
		\For{each particle i}{
			compute velocity at next time stamp $ \boldsymbol{v}_{i}\left(t + \Delta t\right) $\;
			compute position at next time stamp $ \boldsymbol{x}_{i}\left(t + \Delta t\right) $\;
		}
	}
\end{algorithm}
\normalsize

\subsection{Particle Sampling}
\subsubsection{Fluid Sampling}

The fluid particles are initialized within the interior of an axis-aligned cube using a fixed sampling distance $ d_{0} $. Given a fixed rest density $ \rho_{0} $ for the fluid, the total mass of the fluid $ M_{fluid} $ can be calculated according to

\begin{equation}
	\label{eq1}
	M_{fluid} = \rho_{0} \cdot w_{a} \cdot w_{b} \cdot w_{c},
\end{equation}

where $ w_{a} $, $ w_{b} $ and $ w_{c} $ are the widths of the cube arris along x-, y- and z-axis respectively. Since we apply isometric sampling on the fluid volume, the total number of fluid particles $ N_{fluid} $ can be computed as

\begin{equation}
	\label{eq2}
	N_{fluid} = \ceil{\frac{w_{a}}{d_{0}}} \cdot \ceil{\frac{w_{b}}{d_{0}}} \cdot \ceil{\frac{w_{c}}{d_{0}}}.
\end{equation}

Assuming all fluid particles share a common mass $ M_{0} $ and therefore a common diameter $ D_{0} $, we may compute these properties of the fluid as

\begin{equation}
	\label{eq3}
	M_{0} = \frac{M_{fluid}}{N_{fluid}}, \quad D_{0} = \left(\frac{M_{0}}{\rho_{0}}\right)^{\frac{1}{3}}.
\end{equation}

The fluid particles should be sampled in a way such that after initialization the density within the interior of the fluid cube approximates the rest density. To ensure that this is accomplished regardless of the choice on cube volume, $ d_{0} $ and $ \rho_{0} $, we enforce the following nummerical dependency for the rest of this report:

\begin{equation}
	\label{eq4}
	10h = 5H = 12D_{0}
\end{equation}

where $ h $ and $ H $ are the smoothing length and the support radius of the interpolation kernel respectively.

\subsubsection{Boundary Sampling}

Triangles are the basic elements of larger boundary structures. Taking the following steps is a possible way to densely sample solid particles on a triangle:

\begin{itemize}
    \item expand the original triangle by a half of the sampling distance.
    \item establish a pair of normalized orthogonal basis vectors $ \boldsymbol{u} $ and $ \boldsymbol{v} $ that would organize a grid.
    \item generate particles located at the nodes of the aforementioned grid and discard particles that are generated outside the expanded triangle.
    \item correct the particle masses by applying representative volume concept.
\end{itemize}

\paragraph{Expansion of the Triangle} The first of these steps can be done efficiently by simple geometric manipulation. Assuming the three vertices A, B and C of the original triangle take position $ \boldsymbol{x}_{A} $, $ \boldsymbol{x}_{B} $ and $ \boldsymbol{x}_{C} $, we may compute normals for edges AB and BC within the plane in which the triangle lies as

\begin{equation}
\begin{split}
	\label{eq5}
	\boldsymbol{n}_{AB} &= \left(\boldsymbol{x}_{B} - \boldsymbol{x}_{A}\right) \times \left(\boldsymbol{x}_{C} - \boldsymbol{x}_{B}\right) \times \left(\boldsymbol{x}_{B} - \boldsymbol{x}_{A}\right), \\[1em]
	\boldsymbol{n}_{BC} &= \left(\boldsymbol{x}_{C} - \boldsymbol{x}_{B}\right) \times \left(\boldsymbol{x}_{A} - \boldsymbol{x}_{C}\right) \times \left(\boldsymbol{x}_{C} - \boldsymbol{x}_{B}\right).
\end{split}
\end{equation}

Now that we have obtained the edge normals, the new position $ \boldsymbol{x}_{B}^{\prime} $ of vertex B can be computed as

\begin{equation}
	\label{eq6}
	\boldsymbol{x}_{B}^{\prime} = \boldsymbol{x}_{B} - d_{0} \cdot \left(\frac{0.5}{\boldsymbol{n}_{AB} \cdot \boldsymbol{n}_{BC} + 1.0}\right)^{0.5} \cdot \frac{\boldsymbol{n}_{BC}}{\norm{\boldsymbol{n}_{BC}}}.
\end{equation}

The new positions $ \boldsymbol{x}_{C}^{\prime} $ and $ \boldsymbol{x}_{A}^{\prime} $ of vertex C and A can be computed in the same fashion.

\paragraph{Establishment of Basis Vectors} To cope with obtuse triangles, we always choose $ \boldsymbol{u} $ as the unit vector that aligns with the longest edge of the triangle. Without loss of generality, we may assume that edge AB is the longest edge and compute the basis vectors as follows:

\begin{equation}
	\label{eq7}
	\boldsymbol{u} = \frac{\boldsymbol{x}_{B} - \boldsymbol{x}_{A}}{\norm{\boldsymbol{x}_{B} - \boldsymbol{x}_{A}}}, \quad \boldsymbol{v} = \boldsymbol{u} \times \frac{\boldsymbol{x}_{C} - \boldsymbol{x}_{A}}{\norm{\boldsymbol{x}_{C} - \boldsymbol{x}_{A}}} \times \boldsymbol{u}.
\end{equation}

\paragraph{Generation of Particles} To generate solid particles using a square sampling pattern, simply sampling particles at integer strides of the basis vectors suffices. That is, we generate a particle at location $ \boldsymbol{P}_{ij} $ for non-negative integer values of i and j such that

\begin{equation}
	\label{eq8}
	\boldsymbol{P}_{ij} = \boldsymbol{x}_{A} + \left(i \cdot \boldsymbol{u} + j \cdot \boldsymbol{v}\right) \cdot d_{0}.
\end{equation}

As discussed in section \ref{sec5}, a rectangular grid leaves much space inbetween the grid nodes, which can be the cause of undesired circumstances where density estimation near the border largely varies for adjacent fluid particles. To generate solid particles using a hexagonal sampling pattern, we sample a particle at every node of a beehive-grid, that is, every location $ \boldsymbol{P}_{ij} $ for non-negative integer values of i and j such that

\begin{equation}
	\label{eq9}
	\boldsymbol{P}_{ij} = \boldsymbol{x}_{A} + \left(\frac{\sqrt{3}}{2} \cdot i \cdot \boldsymbol{u} + \left( \frac{j \bmod 2}{2} + j\right) \cdot \boldsymbol{v}\right) \cdot d_{0}.
\end{equation}

\paragraph{Correction of Particle Masses} Despite the effort above to sample the boundary with uniformly spaced solid particles, the mass distribution of the border may look quite different near an intersection line between triangular meshes. To allow for uniform mass distribution in the border, mass correction based on the representative volume technique proposed by \cite{akinci2012versatile} is adopted. Assuming all solid particles share the same mass $ M_{b} $, the volume $ V_{k} $ of a solid particle $ k $ may be computed as:

\begin{equation}
	\label{eq10}
    V_{k} = \frac{M_{b}}{\rho_{b}} = \frac{M_{b}}{\sum_{l \in \mathcal{N}_{k}} M_{b} W_{kl}} = \frac{1.0}{\sum_{l \in \mathcal{N}_{k}} W_{kl}},
\end{equation}

where $ \rho_{b} $ is the rest density for the boundary in general and $ \mathcal{N}_{k} $ is the set of particle neighbors for particle $ k $.

\subsection{Kernel Computation}

SPH-based solvers approximate function values over a continuous domain by computing a weighted average over the local neighborhood at discrete particle locations. The kernel function $ W $ and its derivative, therefore, serve as the cornerstone of SPH-based simulation, since they essentially determine the amount of influence each neighbor exerts on the particle in question. An ideal kernel function, due to its interpolation nature, is expected to inherit a handful of characters. The cubic spline function is a typical candidate for such a kernel:

\begin{equation}
	\label{eq11}
	s\left(q\right) = \frac{3}{2\pi}\left\{
	\begin{array}{ll}
            \frac{2}{3} - q^{2} + \frac{1}{2}q^{3}	& \quad 0 \leq q < 1 \\[1em]
            \frac{1}{6}\left(2 - q\right)^{3}		& \quad 1 \leq q < 2 \\[1em]
            0	& \quad 2 \leq q
    \end{array}
    \right..
\end{equation}

We may compute the derivative of the cubic spline function as

\begin{equation}
	\label{eq12}
	s^{\prime}\left(q\right) = \frac{3}{2\pi}\left\{
	\begin{array}{ll}
            -2q + \frac{3}{2}q^{2}					& \quad 0 \leq q < 1 \\[1em]
            -\frac{1}{2}\left(2 - q\right)^{2}		& \quad 1 \leq q < 2 \\[1em]
            0	& \quad 2 \leq q
    \end{array}
    \right..
\end{equation}

where $ q = \frac{\norm{\boldsymbol{x}_{i} - \boldsymbol{x}_{j}}}{h} $ is the normalized distance between particle $ i $ and its neighbor $ j $.

\subsection{Density Estimation}

Typical SPH-based solvers distinguish between the rest density $ \rho_{0} $ of the fluid and the estimated density $ \rho_{i} $ of a particular fluid particle $ i $. For incompressible fluid, $ \rho_{0} $ is expected to remain constant at every point within the fluid domain. For any particular particle $ i $, however, the estimated density $ \rho_{i} $ is an artificial property used to model the small amount of density deviation that is experienced in the local neighborhood. To counteract such deviation, pressure forces may be applied in each time step to guarantee volume conservation and thus water-like behaviour of the particles on a large scale. We may estimate the density of a particular fluid particle $ i $ as:

\begin{equation}
    \label{eq13}
    \rho_{i} = \rho(\mathbf{x}_{i}) \approx \sum_{j \in \mathcal{N}_{i}:j \in \mathcal{F}} m_{j} W_{ij} + \sum_{k \in \mathcal{N}_{i}:k \in \mathcal{B}} \rho_{b} V_{k} W_{ik}
\end{equation}

where

\begin{itemize}
    \item $ \mathcal{F} $ is the set of fluid particles.
    \item $ \mathcal{B} $ is the set of solid particles.
    \item $ m_{j} $ is the mass associated with fluid particle $ j $.
    \item $ V_{k} $ is the representative volume of solid particle $ k $.
    \item $ W_{ij} $ is kernel function value evaluated at relative position $ \mathbf{x}_i - \mathbf{x}_j $.
\end{itemize}

\subsection{Acceleration Computation}

Rather than to enforce strict incompressibility throughout the fluid domain, WC-SPH allows a minor amount of volume compression when fluid particles heavily interact with other particles. Under such circumstances, per-particle density estimation in densely resided regions in the fluid domain would exhibit a deviation from the rest density of the fluid. As a logical consequence, we may evaluate the pressure field at discrete particle locations and observe considerable variances. From such variances, WC-SPH generates a counteractive force for each particle against the spatial gradient of the pressure field in the local neighborhood. An evaluation of the pressure field at the discrete particle location $ \boldsymbol{x}_{i} $ may look like:

\begin{equation}
	\label{eq14}
    p_{i} = \max(0, \kappa(\rho_{i} - \rho_{0}))
\end{equation}

where $ \kappa $ is an artificial hyperparam that refers to the stiffness of the fluid. Negative pressure values are clamped to zero out of the practical concern to avoid clotting behaviour where particle neighborhoods are under-populated. WC-SPH solvers compute in each time step the internal and external forces that act upon a particle via an array of explicit equations. Accelerations that result from such forces are then accumulated and passed on for time integration. In our implementation we separately compute the following component forces for each fluid particle $ i $:

\begin{itemize}
    \item The pressure component $ \mathbf{F}_{i}^{p} $ as a result of interation with fluid particle neighbors.
    \item The pressure component $ \mathbf{G}_{i}^{p} $ as a result of interation with solid particle neighbors.
    \item The viscosity component $ \mathbf{F}_{i}^{v} $ as a result of velocity inconformity in the local space.
    \item The friction component $ \mathbf{G}_{i}^{v} $ as a result of friction with its solid particle neighbors.
    \item The external component $ \mathbf{F}_{i}^{e} $.
\end{itemize}

Accelerations are then accumulated as:

\begin{equation}
	\label{eq15}
	\boldsymbol{a}_{i} = \left(\mathbf{F}_{i}^{p} + \mathbf{F}_{i}^{v} + \mathbf{F}_{i}^{e} + \nu \cdot \mathbf{G}_{i}^{p} + \mu \cdot \mathbf{G}_{i}^{v} \right) / M_{0}
\end{equation}

where $ \nu $ and $ \mu $ are artificial hyperparams used to weight the respective components. We conduct ablation studies in Sec. \ref{sec4} to understand the effects of the aforementioned hyperparams.

\subsection{Time Integration}

In WC-SPH simulation, the maximum time step size allowed at the current state is upper-bounded by the CFL condition \eqref{eq16}. Intuitively, the CFL condition enforces that a particle does not travel in one time step a distance that exceeds half the particle diameter $ D_{0} $. In practice, however, such a condition may not be sufficient to avoid the occurence of excessive pressure, especially in cases where particles obtain high kinematic energy due to intensive interactions. Therefore, a hard cap $ T_{0} $ is introduced as a further constraint.

\begin{equation}
	\label{eq16}
	\Delta t_{courant} = 0.5 \cdot \frac{D_{0}}{\norm{\boldsymbol{v}_{max}}}
\end{equation}

An outline of our simulation pipeline is illustrated in Alg. \ref{alg2}. To be able to render the scene directly from instant snapshots of the system, we implement our simulation loop in a way such that time lardmarks, which are defined as multiples of the hard cap $ T_{0} $, are never jumped over. Within each pass of the while-loop, we determine the time step size $ \Delta t $ from the current state, perform one physical update and increment the simulation time by $ \Delta t $.

\large
\begin{algorithm}
	\SetAlgoLined
	\SetAlgorithmName{Algorithm}{Algorithm}{List of Algorithms}
	\SetAlCapNameSty{textbf}
	\caption{\label{alg2} Simulation Loop}
	\SetKwFunction{FMain}{Main}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FMain{}}{
		$ sample\_fluid() $\;
		$ sample\_border() $\;
		\For{each landmark frame i}{
			$ t = 0 $\;
			\While{$ t < T_{0} $}{
				$ \Delta t_{courant} = bound\_CFL() $\;
				$ \Delta t = min(\Delta t_{courant}, T_{0} - t) $\;
				$ update(\Delta t) $\;
				$ t = t + \Delta t $\;
			}
			$ save\_state() $\;
		}
	}
\end{algorithm}
\normalsize

The time step size $ \Delta t $ directly influences how far the system evolves into the future with one time integration step. Here we adopt a modified version of the standard symplectic Euler integration scheme:

\begin{align}
	\label{eq17} \mathbf{v}_{i}(t + \Delta t) &= \mathbf{v}_{i}(t) + \Delta t \cdot \mathbf{a}_{i} \\[1em]
	\label{eq18} \mathbf{v}_{i}^{*} &= \mathbf{v}_{i}(t + \Delta t) + 2\epsilon \sum_{j \in \mathcal{N}_{i}} m_{j} \frac{\mathbf{v}_{j}(t + \Delta t) - \mathbf{v}_{i}(t + \Delta t)}{\rho_{i} + \rho_{j}} W_{ij} \\[0.5em]
	\label{eq19} \mathbf{x}_{i}(t + \Delta t) &= \mathbf{x}_{i}(t) + \Delta t \cdot \mathbf{v}_{i}^{*}
\end{align}

where $ \mathbf{v}_{i}^{*} $ is an intermediate velocity obtained by adding to $ \mathbf{v}_{i}(t + \Delta t) $ a small bias that is a weighted average of the velocity differences in the local neighborhood and $ \epsilon $ is a hyperparam that controls the magnitude of such a small bias. This modification aims at denoising particle motion in the local area and improves visual plausibility of the animation.

\section{Position-based Fluid}
\label{sec3}

\large
\begin{algorithm}
	\DontPrintSemicolon
	\SetAlgoLined
	\SetAlgorithmName{Algorithm}{Algorithm}{List of Algorithms}
	\SetAlCapNameSty{textbf}
	\caption{\label{alg3} A Single PBF-SPH Update}
	\SetKwFunction{FMain}{update}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FMain{$ \Delta t $}}{
		\For{each particle i}{
			compute density $ \rho_{i} $\;
		}
		\For{each particle i}{
			compute acceleration $ \boldsymbol{a}_{i} $\;
		}
		\For{each particle i}{
			compute velocity at next time stamp $ \boldsymbol{v}_{i}\left(t + \Delta t\right) $\;
			store old position $ \bar{\boldsymbol{x}}_i $\;
			compute position at next time stamp $ \boldsymbol{x}_{i}\left(t + \Delta t\right) $\;
		}
		\For{each particle i}{
			find neighbors j\;
		}
		\For{each iteration t}{
			\For{each particle i}{
				compute density $ \rho_{i} $\;
				compute density constraint violation $ C_{i} $\;
				compute expression $ S_{i} $\;
				compute position correction stride $ \lambda_{i} $\;
			}
			\For{each particle i}{
				compute position correction $ \Delta \boldsymbol{x}_{i} $\;
				correct position $ \boldsymbol{x}_{i} $\;
			}
		}
		\For{each particle i}{
			update velocity $ \boldsymbol{v}_{i} $ from old position $ \bar{\boldsymbol{x}}_{i} $\;
		}
	}
\end{algorithm}
\normalsize

Instead of introducing an artificial pressure force to counteract density deviation, position-based fluid poses a scalar constraint $ C_{i} $ on the estimated density of each fluid particle $ i $:

\begin{equation}
	\label{eq20}
	C_{i}(\hat{\boldsymbol{x}}) = \frac{\rho_{i}(\hat{\boldsymbol{x}})}{\rho_{0}} - 1 = 0
\end{equation}

where $ \hat{\boldsymbol{x}} $ denotes the concatenation of all position vectors involved in the computation of $ \rho_{i} $. The fulfillment of such a constraint implies that the fluid is largely at rest state in the local neighborhood and that the density of the respective particle lies roughly around $ \rho_{0} $. Under circumstances where such a constraint is violated, however, the solver seeks to find, in an Newton-like iterative manner, a position correction $ \Delta \hat{\boldsymbol{x}} $ that would locally restore the system to the rest state:

\begin{equation}
	\label{eq21}
	C_{i}(\hat{\boldsymbol{x}} + \Delta \hat{\boldsymbol{x}}) = 0
\end{equation}

\subsection{Position Correction}

An outline of a single PBF update is shown in Alg. \ref{alg3}. In each time step, accelerations that result from a range of internal and external forces are evaluated and then used to perform one time integration step. Then, the violation of the density constraint is determined for each particle and, out of the need to enforce energy convervation, we compute a position correction $ \Delta \hat{\boldsymbol{x}} $ that lies in the opposite direction as the spatial gradient of the constraint $ \nabla C_{i} $:

\begin{equation}
	\label{eq22}
	\Delta \hat{\boldsymbol{x}} = M^{-1} \nabla C_{i} \cdot \lambda_{i}
\end{equation}

where $ \lambda_{i} $ is the single variable that controls the stride of the correction. By pulling Eq. \eqref{eq22} into the first-order Taylor expansion of Eq. \eqref{eq21} we obtain:

\begin{equation}
	\label{eq23}
	C_{i}(\hat{\boldsymbol{x}}) + (\nabla C_{i})^{T} \Delta \hat{\boldsymbol{x}} = C_{i}(\hat{\boldsymbol{x}}) + (\nabla C_{i})^{T} M^{-1} \nabla C_{i} \cdot \lambda_{i} = 0
\end{equation}

As a logical next step we may compute $ \lambda_{i} $ as

\begin{equation}
	\label{eq24}
	\lambda_{i} = - \frac{\sigma \cdot C_{i}(\hat{\boldsymbol{x}})}{S_{i} + \epsilon}.
\end{equation}

where

\begin{itemize}
    \item $ S_{i} = (\nabla C_{i})^{T} M^{-1} \nabla C_{i} $.
    \item $ \epsilon $ is a small value added for nummerical stability.
    \item $ \sigma $ is an artificial damper used to downscale the correction stride.
\end{itemize}

Since the we are practically reaching for the solution of a non-linear system of equations with a linear approach, this correction may be applied multiple times until the violation shrinks to an acceptable scale. We conduct ablation study on how the number of corrective iterations and the introduction of the stride damper affect the behaviour of the fluid in Sec. \ref{sec4}.

\subsection{Surface Tension}

To allow our simulations to further impress, cohesion forces and adhesion forces are added to our implementation to model surface tension at microscopic level.

\paragraph{Cohesion Forces}

Cohesion forces model the interation between a pair of water molecules when they get close. The distance between the two molecules decide whether they attract or repel each other. Given a special kernel function $ W^{c} $, the cohesion force incurred by a fluid particle in our simulation may be approximated as:

\begin{equation}
	\label{eq25}
	\mathbf{F}_{i}^{c} = - \gamma m_{i} \sum_{j \in \mathcal{N}_{i}:j \in \mathcal{F}} m_j K_{ij} W^{c}(\norm{\mathbf{x}_{i} - \mathbf{x}_{j}}, H) \cdot \frac{\mathbf{x}_{i} - \mathbf{x}_{j}}{\norm{\mathbf{x}_{i} - \mathbf{x}_{j}}}
\end{equation}

where $ \gamma $ is a hyperparam that controls the scale and $ K_{ij} = \frac{\rho_{i} + \rho_{j}}{2\rho_{0}} $ is a normalizer that compensates for under-population in the local space. Since cohesion forces alone are in practice insufficient to guarantee a water-like fluid surface, we introduce an additional component $ \mathbf{F}_{i}^{n} $ that counteracts a high curvature by enforcing surface normals evaluated at adjacent particle locations to be similar:

\begin{equation}
	\label{eq26}
	\mathbf{F}_{i}^{n} = - \gamma m_{i} \sum_{j \in \mathcal{N}_{i}:j \in \mathcal{F}} K_{ij} (\mathbf{n}_{i} - \mathbf{n}_{j})
\end{equation}

where $ \mathbf{n}_{i} $ and $ \mathbf{n}_{j} $ are surface normals at particle locations $ \mathbf{x}_{i} $ and $ \mathbf{x}_{j} $ respectively. Such surface normals in the fluid domain may be computed as:

\begin{equation}
	\label{eq27}
	\mathbf{n}_{i} = H \sum_{j \in \mathcal{N}_{i}:j \in \mathcal{F}} \frac{m_{j}}{\rho_{j}} \nabla W_{ij}
\end{equation}

For particles on the fluid interface this normal vector points in the direction that is orthogonal to the fluid surface, whereas for interior particles its magnitude remains close to zero.

\paragraph{Adhesion Forces}

Adhesion forces model the attraction between a pair of fluid and solid molecules in close vicinity. Given a special kernel function $ W^{a} $, the adhesion force incurred by a fluid particle in our simulation may be computed as:

\begin{equation}
	\label{28}
	\mathbf{F}_{i}^{a} = - \beta m_{i} \sum_{k \in \mathcal{N}_{i}:k \in \mathcal{B}} V_{k} W^{a}(\norm{\mathbf{x}_{i} - \mathbf{x}_{k}}, H) \cdot \frac{\mathbf{x}_{i} - \mathbf{x}_{k}}{\norm{\mathbf{x}_{i} - \mathbf{x}_{k}}}
\end{equation}

where $ \beta $ is a hyperparam that controls the scale. Effects of the aforementioned hyperparams are discussed in Sec. \ref{sec4}.

\section{Experiments}
\label{sec4}

We carry out a wide range of experiments to study the effects of various hyperparams on the behaviour of fluid particles and of the fluid in general.

\subsection{WC-SPH}
For WC-SPH we fix the scale of our scene and conduct control experiments to test out how different values of pressure stiffness $ \kappa $, viscosity $ \nu $ and friction $ \nu$ would lead to different characteristics of the fluid. Our dam break scene adopts the following configuration:

\begin{itemize}
    \item Boundary domain: $ 1m \times 5m \times 3m $
    \item Fluid volume: $ 0.5m \times 3m \times 0.5m $
    \item Sampling distance: $ 0.1m $
    \item Maximal timestep: 20ms
    \item number of particles: 5000
    \item gravity $ 9.7 m \cdot s^{-2} $
\end{itemize}

The selection of proper hyperparam values is sensitive to the domain size and sampling distance. For the aforementioned dam break scene we find visually realistic simulations under the combination of $ \kappa = 100.0 $, $ \nu = 0.05 $ and $ \mu = 0.05 $. To tune the hyperparams for a general scene, such a combination could adopted as a starter.

\subsubsection{Pressure Stiffness}

The stiffness coefficient $ \kappa $ is used to scale the pressure forces generated to counteract density deviation. When a low stiffness coefficient is applied, volume conservation fails to a large extent and some fluid particles leak through the container boundary since there is not enough pressure force to prevent such penetration. The estimated density in the bottom part of the fluid domain will significantly exceed the rest density of the fluid. On the other hand, when the stiffness value is set too high, the counteractive pressure forces are so intense that they will cause instant explosions upon even mild particle interactions.

\subsubsection{Viscosity}
The viscosity coefficient $ \nu $ is used to scale the tractive forces that acts inbetween fluid particles to model the viscous behaviour of the fluid. With such a force applied in a proper scale, the kinematic energy of a high-speed particle can be transferred to adjacent low-speed particles so that the divergence of the local velocity field is lessened and that the fluid particles end up moving as a whole locally. As can be obeserved in Fig. \ref{fig:visco}, on the other hand, a viscosity coefficient too low results in a simulation in which the fluid particles behave rather like randomly bouncing molecules. This implies that the application of viscosity forces indeed dampens the energy of the system as a side effect.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{pics/wcsph_viscosity.png}
    \caption{Left: well-tuned simulation of a dam break scene; Right: simulation of the same scene with rather low viscosity.}
    \label{fig:visco}
\end{figure}

\subsubsection{Friction}
Similar to $ \nu $, the friction coefficient $ \mu $ is also used to scale a tractive force. What is different is that the latter controls the level of traction between fluid and solid particles. To easily demonstrate the effect of this hyperparam, we tip the container and the fluid cube by a 45-degree angle as an initial configuration. As is shown in Fig. \ref{fig:frict}, with properly scaled friction forces the fluid particles will flow down rather slowly along the slope, which does not happen with a low friction.

\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{pics/wcsph_friction.png}
    \caption{Left: well-tuned simulation of a tipped dam break scene; Right: simulation of the same scene with rather low friction.}
    \label{fig:frict}
\end{figure}

\section{Miscellaneous}
\label{sec5}

\bibliographystyle{alpha}
\bibliography{references}

\end{document}
