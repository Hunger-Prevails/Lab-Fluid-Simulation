\documentclass[
	11pt, 
	DIV10,
	ngerman,
	a4paper, 
	oneside, 
	headings=normal, 
	captions=tableheading,
	final, 
	numbers=noenddot
]{scrartcl}


\usepackage[ruled]{algorithm2e}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

\title{Fully Asynchronous SPH Simulation}
\subtitle{\vspace{0.5cm}Lab: Fluid Simulation}
\author{Yinglun, Qihui, Iohannes}


\begin{document}
\maketitle


\section{Motivation}

In this work, we follow the basic principles of smoothed particle hydrodynamics(SPH) to implement two of the most classic approaches in fluid simulation. We carry out extensive studies on the behavior of fluid particles under varying experimental conditions, as well as provide a handful of insights on how the stability or efficiency of the simulation could be improved by applying a few twists during various stages of the algorithms. The rest of this report will be divided into four sections. In section \ref{sec2}, we underscore the engineering aspect of a non-iterative, weakly-compressible SPH solver; in section \ref{sec3}, we discuss how an iterative procedure can be implemented to model position-based fluid; in section \ref{sec4}, we demonstrate several scenes featuring a variety of fluid behaviors to show the correctness and stability of our implementation; in the last section \ref{sec5}, we discuss how the hyper parameters affect the behavior of the fluid and how we may improve the simulation in terms of speed and robustness.


\section{Weakly Compressible SPH}
\label{sec2}

Weakly Compressible SPH updates the physical properties of fluid particles through an array of explicit state equations. Fluid particles move around as a result of inter-particle interactions and external forces that act upon them. To find out where fluid particles should go in the next time step, typically pressure forces and viscosity forces are considered as the dominant components of the interaction forces. Pressure forces counteract any deviation from the rest density in the fluid volume. Viscosity forces counteracts the divergence of the velocity field in the local space. The outline of a single WC-SPH update step is shown in Alg. \ref{alg1}. At the beginning of such an update step, a neighborhood search is carried out to determine the spatial neighbors of each fluid particle. Fluid neighbors and boundary neighbors are stored separately so that the physical properties of the fluid particle in question may be interpolated from them later. Such an interpolation requires the existence of an kernel function that features a variety of characters. Then, the fluid particle densities are estimated as they will be needed for the computation of interaction forces. As a logical next step, the incurred forces are computed for each particle and the accelerations are accumulated for time integration. Typically the symplectic Euler scheme is used for time integration for its simplicity, although velocity smoothing could be adopted after velocity update for improved robustness against heavy bounces.

Apart from the physical update of the particles, the particle sampling strategies for initializing the fluid and the boundary play an important role as well, since they indirectly determine the particle diameters and thus the smoothing length of the kernel function. Another key factor that needs to be handled with discretion is the time step size of each physical update. Too large a time step results in destabilized simulation and incorrect particle interactions, while too small a time step leads to considerable waste of computational power. In the following, we unfold in detail some key aspects for implementing such a WC-SPH solver.

\large
\begin{algorithm}
	\DontPrintSemicolon
	\SetAlgoLined
	\SetAlgorithmName{Algorithm}{Algorithm}{List of Algorithms}
	\SetAlCapNameSty{textbf}
	\caption{\label{alg1} A Single WC-SPH Update}
	\SetKwFunction{FMain}{update}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FMain{$ \Delta t $}}{
		\For{each particle i}{
			find neighbors j\;
		}
		\For{each particle i}{
			compute density $ \rho_{i} $\;
		}
		\For{each particle i}{
			compute pressure force $ \boldsymbol{F}_{i}^{p} $\;
			compute viscosity force $ \boldsymbol{F}_{i}^{v} $\;
			compute cohesion force $ \boldsymbol{F}_{i}^{c} $\;
			compute adhesion force $ \boldsymbol{F}_{i}^{a} $\;
			compute external force $ \boldsymbol{F}_{i}^{e} $\;
			compute acceleration $ \boldsymbol{a}_{i} $\;
		}
		\For{each particle i}{
			compute velocity at next time stamp $ \boldsymbol{v}_{i}\left(t + \Delta t\right) $\;
			compute position at next time stamp $ \boldsymbol{x}_{i}\left(t + \Delta t\right) $\;
		}
	}
\end{algorithm}
\normalsize

\subsection{Particle Sampling}
\subsubsection{Fluid Sampling}

The fluid particles are initialized within the interior of an axis-aligned cube using a fixed sampling distance $ d_{0} $. Given a fixed rest density $ \rho_{0} $ for the fluid, the total mass of the fluid $ M_{fluid} $ can be calculated according to

\begin{equation}
	\label{eq1}
	M_{fluid} = \rho_{0} \cdot w_{a} \cdot w_{b} \cdot w_{c},
\end{equation}

where $ w_{a} $, $ w_{b} $ and $ w_{c} $ are the widths of the cube arris along x-, y- and z-axis respectively. Since we apply isometric sampling on the fluid volume, the total number of fluid particles $ N_{fluid} $ can be computed as

\begin{equation}
	\label{eq2}
	N_{fluid} = \ceil{\frac{w_{a}}{d_{0}}} \cdot \ceil{\frac{w_{b}}{d_{0}}} \cdot \ceil{\frac{w_{c}}{d_{0}}}.
\end{equation}

Assuming all fluid particles share a common mass $ M_{0} $ and therefore a common diameter $ D_{0} $, we may compute these properties of the fluid as

\begin{equation}
\begin{split}
	\label{eq3}
	M_{0} &= \frac{M_{fluid}}{N_{fluid}}, \\[1em]
	D_{0} &= \sqrt[3]{\frac{M_{0}}{\rho_{0}}}.
\end{split}
\end{equation}

The fluid particles should be sampled in a way such that after initialization the density within the interior of the fluid cube approximates the rest density. To ensure that this is accomplished regardless of the user's choice on cube volume, the sampling distance and the rest density, we enforce the following nummerical dependency for the rest of this report:

\begin{equation}
\begin{split}
	\label{eq4}
	h &= 1.2D_{0}, \\[1em]
	H &= 2.4D_{0}.
\end{split}
\end{equation}

Here $ h $ and $ H $ are the smoothing length and the support radius of interpolating kernel function respectively.

\subsubsection{Boundary Sampling}

Triangles are the basic elements of larger boundary structures. Taking the following steps is a possible way to densely sample boundary particles on a triangle:

\begin{itemize}
    \item expand the original triangle by a half of the sampling distance.
    \item establish a pair of normalized orthogonal basis vectors $ \boldsymbol{u} $ and $ \boldsymbol{v} $ that would organize a grid.
    \item generate particles located at the nodes of the aforementioned grid and discard particles that are generated outside the expanded triangle.
    \item translate the generated particles by a common offset such that the center of their mass align with the center of the triangle.
\end{itemize}

\paragraph{Expansion of the Triangle} The first of these steps can be done efficiently by simple geometric manipulation. Assuming the three vertices A, B and C of the original triangle take position $ \boldsymbol{x}_{A} $, $ \boldsymbol{x}_{B} $ and $ \boldsymbol{x}_{C} $, we may compute normals for edges AB and BC within the plane in which the triangle lies as

\begin{equation}
\begin{split}
	\label{eq5}
	\boldsymbol{n}_{AB} &= \left(\boldsymbol{x}_{B} - \boldsymbol{x}_{A}\right) \times \left(\boldsymbol{x}_{C} - \boldsymbol{x}_{B}\right) \times \left(\boldsymbol{x}_{B} - \boldsymbol{x}_{A}\right), \\[1em]
	\boldsymbol{n}_{BC} &= \left(\boldsymbol{x}_{C} - \boldsymbol{x}_{B}\right) \times \left(\boldsymbol{x}_{A} - \boldsymbol{x}_{C}\right) \times \left(\boldsymbol{x}_{C} - \boldsymbol{x}_{B}\right).
\end{split}
\end{equation}

Now that we have obtained the edge normals, the new position $ \boldsymbol{x}_{B}^{\prime} $ of vertex B can be computed as

\begin{equation}
	\label{eq6}
	\boldsymbol{x}_{B}^{\prime} = \boldsymbol{x}_{B} - d_{0} \cdot \left(\frac{0.5}{\boldsymbol{n}_{AB} \cdot \boldsymbol{n}_{BC} + 1.0}\right)^{0.5} \cdot \frac{\boldsymbol{n}_{BC}}{\norm{\boldsymbol{n}_{BC}}}.
\end{equation}

The new positions $ \boldsymbol{x}_{C}^{\prime} $ and $ \boldsymbol{x}_{A}^{\prime} $ of vertex C and A can be computed in the same fashion.

\paragraph{Determination of Basis Vectors} To cope with obtuse triangles, we always choose $ \boldsymbol{u} $ as the unit vector that aligns with the longest edge of the triangle. Without loss of generality, we may assume that edge AB is the longest edge and compute the basis vectors as follows:

\begin{equation}
\begin{split}
	\label{eq7}
	\boldsymbol{u} &= \frac{\boldsymbol{x}_{B} - \boldsymbol{x}_{A}}{\norm{\boldsymbol{x}_{B} - \boldsymbol{x}_{A}}}, \\[1em]
	\boldsymbol{v} &= \boldsymbol{u} \times \frac{\boldsymbol{x}_{C} - \boldsymbol{x}_{A}}{\norm{\boldsymbol{x}_{C} - \boldsymbol{x}_{A}}} \times \boldsymbol{u}.
\end{split}
\end{equation}

\paragraph{Generation of Particles} To generate boundary particles using a square sampling pattern, simply sampling particles at integer strides of the basis vectors suffices. That is, we generate a particle at location $ \boldsymbol{P}_{ij} $ for non-negative integer values of i and j such that

\begin{equation}
	\label{eq8}
	\boldsymbol{P}_{ij} = \boldsymbol{x}_{A} + \left(i \cdot \boldsymbol{u} + j \cdot \boldsymbol{v}\right) \cdot d_{0}.
\end{equation}

As discussed in section \ref{sec5}, a rectangular grid leaves much space inbetween the grid nodes, which can be the cause of undesired circumstances where density estimation near the border largely varies for adjacent fluid particles. To generate boundary particles using a hexagonal sampling pattern, we sample a particle at every node of a beehive-grid, that is, every location $ \boldsymbol{P}_{ij} $ for non-negative integer values of i and j such that

\begin{equation}
	\label{eq9}
	\boldsymbol{P}_{ij} = \boldsymbol{x}_{A} + \left(\frac{\sqrt{3}}{2} \cdot i \cdot \boldsymbol{u} + \left( \frac{j \bmod 2}{2} + j\right) \cdot \boldsymbol{v}\right) \cdot d_{0}.
\end{equation}

Despite the effort above to sample the boundary with uniformly spaced boundary particles, the mass distribution of the border may look quite different near an intersection line between triangular meshes. To allow for uniform mass distribution in the border, mass correction based on the representative volume technique proposed by \cite{akinci2012versatile} is adopted. Assuming all boundary particles share the same mass $ M_{0} $, the volume $ V_{k} $ of a boundary particle $ k $ may be computed as:

\begin{equation}
	\label{eq10}
    V_{k} = \frac{M_{0}}{\rho_{b}} = \frac{M_{0}}{\sum_{l \in \mathcal{N}_{k}} M_{0} W_{kl}} = \frac{1.0}{\sum_{l \in \mathcal{N}_{k}} W_{kl}},
\end{equation}

where $ \rho_{b} $ is the rest density for the boundary in general.

\subsection{Kernel Computation}

SPH-based solvers approximate function values over a continuous domain by computing a weighted average over the local neighborhood at discrete particle locations. The kernel function $ W $ and its derivative, therefore, serve as the cornerstone of SPH-based simulation, since they essentially determine the amount of influence each neighbor exerts on the particle in question. An ideal kernel function, due to its interpolation nature, is expected to inherit a handful of properties such as:

\begin{itemize}
    \item The function has an integral value of one over its acting domain.
    \item The function approximates the $ Dirac $-$ \delta $ distribution as its smoothing length approaches zero.
    \item The function is non-negative.
    \item The function is symmetric.
    \item The function is of compact support (i.e. the function value remains zero beyond this support range).
    \item The function is (at least piecewise) continuous and differentiable.
\end{itemize}

The cubic spline function is a typical candidate for such a kernel:

\begin{equation}
	\label{eq11}
	s\left(q\right) = \frac{3}{2\pi}\left\{
	\begin{array}{ll}
            \frac{2}{3} - q^{2} + \frac{1}{2}q^{3}	& \quad 0 \leq q < 1 \\[1em]
            \frac{1}{6}\left(2 - q\right)^{3}		& \quad 1 \leq q < 2 \\[1em]
            0	& \quad 2 \leq q
    \end{array}
    \right..
\end{equation}

We may compute the derivative of the cubic spline function as

\begin{equation}
	\label{eq12}
	s^{\prime}\left(q\right) = \frac{3}{2\pi}\left\{
	\begin{array}{ll}
            -2q + \frac{3}{2}q^{2}					& \quad 0 \leq q < 1 \\[1em]
            -\frac{1}{2}\left(2 - q\right)^{2}		& \quad 1 \leq q < 2 \\[1em]
            0	& \quad 2 \leq q
    \end{array}
    \right..
\end{equation}

The final interpolation function and its spatial gradient w.r.t. to the position $ \boldsymbol{x} $ of the particle in question can then be computed as

\begin{equation}
\begin{split}
	\label{eq13}
	W\left(\boldsymbol{x}, \boldsymbol{y}, h\right) &= \frac{1}{h^{3}}s\left(q\right) \\[1em]
	\nabla_{\boldsymbol{x}} W &= \frac{1}{h^{4}} \cdot \frac{\boldsymbol{x} - \boldsymbol{y}}{\norm{\boldsymbol{x} - \boldsymbol{y}}} \cdot s^{\prime}\left(q\right),
\end{split}
\end{equation}

where $ \boldsymbol{y} $ refer to the position of the neighbor particle and $ q = \frac{\norm{\boldsymbol{x} - \boldsymbol{y}}}{h} $ is the normalized distance between the particle in question and its neighbor.

\subsection{Density Estimation}

Typical SPH-based solvers distinguish between the rest density $ \rho_{0} $ of the fluid and the estimated density $ \rho_{i} $ of a particular fluid particle $ i $. For incompressible fluid, $ \rho_{0} $ is expected to remain constant at every point within the fluid domain. For any particular particle $ i $, however, the estimated density $ \rho_{i} $ is an artificial property used to model the small amount of density deviation that is experienced in the local neighborhood. To counteract such deviation, pressure forces may be applied in each time step to guarantee volume incompressibily and thus water-like behaviour of the particles on a large scale. We may estimate the density of a particular fluid particle $ i $ as:

\begin{equation}
    \label{eq14}
    \rho_{i} = \rho(\mathbf{x}_{i}) \approx \sum_{j \in \mathcal{N}_{i}^{f}} m_{j} W_{ij} + \sum_{k \in \mathcal{N}_{i}^{b}} \rho_{b} V_{k} W_{ik}
\end{equation}

where

\begin{itemize}
    \item $ \mathcal{N}_{i}^{f} $ and $ \mathcal{N}_{i}^{b} $ are the set of fluid and solid neighbors respectively.
    \item $ m_{j} $ is the mass associated with fluid particle $ j $.
    \item $ V_{k} $ is the representative volume of boundary particle $ k $.
    \item $ W_{ij} $ is kernel function value evaluated at relative position $ \mathbf{x}_i - \mathbf{x}_j $.
\end{itemize}

\subsection{Acceleration Computation}



\subsection{Time Step Determination}

\begin{equation}
	\Delta t_{courant} = 0.5 \cdot \frac{D_{0}}{\norm{\boldsymbol{v}_{max}}}
\end{equation}

\large
\begin{algorithm}
	\SetAlgoLined
	\SetAlgorithmName{Algorithm}{Algorithm}{List of Algorithms}
	\SetAlCapNameSty{textbf}
	\caption{\label{alg1} Simulation Loop}
	\SetKwFunction{FMain}{Main}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FMain{}}{
		$ sample\_fluid() $\;
		$ sample\_border() $\;
		\For{each landmark frame i}{
			$ t = 0 $\;
			\While{$ t < T_{0} $}{
				$ \Delta t_{courant} = bound\_CFL() $\;
				$ \Delta t = min(\Delta t_{courant}, T_{0} - t) $\;
				$ update(\Delta t) $\;
				$ t = t + \Delta t $\;
			}
			$ save\_state() $\;
		}
	}
\end{algorithm}
\normalsize

\subsection{Time Integration}

\section{Position-based Fluid}
\label{sec3}

\large
\begin{algorithm}
	\DontPrintSemicolon
	\SetAlgoLined
	\SetAlgorithmName{Algorithm}{Algorithm}{List of Algorithms}
	\SetAlCapNameSty{textbf}
	\caption{\label{alg1} A Single PBF-SPH Update}
	\SetKwFunction{FMain}{update}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FMain{$ \Delta t $}}{
		\For{each particle i}{
			compute density $ \rho_{i} $\;
		}
		\For{each particle i}{
			compute viscosity force $ \boldsymbol{F}_{i}^{v} $\;
			compute cohesion force $ \boldsymbol{F}_{i}^{c} $\;
			compute adhesion force $ \boldsymbol{F}_{i}^{a} $\;
			compute external force $ \boldsymbol{F}_{i}^{e} $\;
			compute acceleration $ \boldsymbol{a}_{i} $\;
		}
		\For{each particle i}{
			compute velocity at next time stamp $ \boldsymbol{v}_{i}\left(t + \Delta t\right) $\;
			store old position $ \bar{\boldsymbol{x}}_i $\;
			compute position at next time stamp $ \boldsymbol{x}_{i}\left(t + \Delta t\right) $\;
		}
		\For{each particle i}{
			find neighbors j\;
		}
		\For{each iteration t}{
			\For{each particle i}{
				compute density $ \rho_{i} $\;
				compute density constraint violation $ C_{i} $\;
				compute expression $ S_{i} $\;
				compute position correction stride $ \lambda_{i} $\;
			}
			\For{each particle i}{
				compute position correction $ \Delta \boldsymbol{x}_{i} $\;
				correct position $ \boldsymbol{x}_{i} $\;
			}
		}
		\For{each particle i}{
			update velocity $ \boldsymbol{v}_{i} $ from old position $ \bar{\boldsymbol{x}}_{i} $\;
		}
	}
\end{algorithm}
\normalsize

\section{Experiments}
\label{sec4}
\section{Miscellaneous}
\label{sec5}

% \bibliographystyle{alpha}
% \bibliography{references}

\end{document}
